---
title: "Problem Set 1"
author: "Sewheat Haile"
date: "2/27/2021"
output: pdf_document
---

```{r setup, message=FALSE}
# load packages
library(tidyverse)
library(gridExtra)
library(kableExtra)
library(knitr)

# make comments wrap in knitted PDF
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80), tidy=TRUE)
```

# Functions

## Q. 1

```{r functions q1}
# sum all observations in vector and divide by total number of observations (length)
pop_mean <- function(vector){
  out_vector <- sum(vector) / length(vector) 
  return(out_vector)
}
```

## Q. 2
```{r functions q2}
# calculate variance by 

# 1) subtracting the population mean from each observation in "vector"

# 2) squaring each value from #1

# 3) summing the squared numbers from #2

# 4) divide the sum from #3 by the total number of observations in "vector" 

pop_var <- function(vector){
  out_vector <- sum((vector - pop_mean(vector))^2) / length(vector)
  return(out_vector)
}
```

## Q. 3
```{r functions q3.1}
# load csv
gapminder <- read.csv("gapminder.csv")

pop_mean(gapminder$lifeExp)

# check function
mean(gapminder$lifeExp) 

pop_var(gapminder$lifeExp)

# check function
var(gapminder$lifeExp)
```

The results for the variance are different because the R function var() calculates the sample variance rather than the population variance. In order to check whether the population variance is correct, I convert the sample variance to population variance by:

--multiplying var() by (n-1), represented by length() - 1

--dividing by var()*(n-1) by (n), represented by length()

```{r functions q3.2}
pop_var(gapminder$lifeExp)

# check function
var(gapminder$lifeExp) * (length(gapminder$lifeExp) - 1) / length(gapminder$lifeExp) 
```

# Data Transformation

## Q. 1

```{r data transformation q1}
# load csv
parent_inc <- read.csv("parent_inc.csv") 

# tidy data
parent_inc %>%

# bring father_name and mother_name from columns to observations under the new column "type", and information from father_name and mother_name into new column "name"
  pivot_longer(
    c('father_name', 'mother_name'), 
    names_to = "type", 
    values_to = "name" ) %>%

# remove "_name" from observations under column "type"
  mutate(
    type = str_remove(type, "_name")) %>%

# bring fincome and mincome from columns to observations under the new column "income_type", and values from fincome and mincome into new column "income"
  pivot_longer(
    c('fincome', 'mincome'),
    names_to = "income_type",
    values_to = "income") %>%

# filter so that the gender of parent under "type" column matches with their income under "income_type" column
  filter ((type == "father" & income_type == "fincome") | 
          (type == "mother" & income_type == "mincome") ) %>%

# remove income_type column
  select(- income_type)
```

# Population, Sample, and Sampling Distribution

## Q. 1
```{r population sample q1}
# set seed to make random code reproducible
set.seed(100)

# create population with 100,000 observations of mean 5 and standard dev of 1 
pop <- rnorm(n = 100000, mean=5, sd=1) %>% 

# convert to data frame
  as_tibble()
```

## Q. 2
```{r population sample q2}
# calculate mean for pop
mean.pop <- mean(pop$value)
mean.pop

# plot histogram with red dashed line at mean
pop %>% 

  ggplot(aes(value)) +

  geom_histogram(binwidth = 0.1, fill = "grey", color = "black") +

  geom_vline(aes(xintercept = mean.pop), color = "red", linetype = "dashed") +

  geom_text(aes(mean.pop, 
                label = paste("population mean =", round(mean.pop, 4)),
                y = -150), 
            colour = "red") +

  labs(title = "Population (N = 100,000, mean = 5, sd = 1)",

       subtitle = "Mean marked by dashed line",

       x = "values in population")
```

## Q. 3
```{r population sample q3}
#  set seed to make random code reproducible
set.seed(1020)

sample50 <- pop %>% 
  sample_n(size = 50, replace = FALSE)
```

## Q. 4
```{r population sample q4}
sample50 %>% 

  ggplot(aes(value)) +
 
  geom_histogram(binwidth = 0.1, fill = "grey", color = "black") +

  geom_vline(aes(xintercept = mean(value)), color = "red", linetype = "dashed") +

  geom_text(aes(mean(value), 
            label = paste("est. population mean =", round(mean(value), 4)),
            y = -0.2), colour = "red") +

  labs(title = "Sample from Population (n = 50, N = 100,000)",

      subtitle = "Estimate population mean marked by dashed line",

       x = "values in sample")
```
Whereas the histogram from question 2 resembled a normal distribution, this one appears to be slightly skewed to the right. In addition, the point estimate for the population mean given by the sample is smaller than the true population mean.

## Q. 5

Sample mean: $\overline y = \frac{y_1 + y_2 + y+3 + ... + y_n}{n}$

Standard error of sample mean: $se = \frac{s}{\sqrt{n}}$

95% Conf. interval of sample mean: $\hat \mu \pm t_{0.025, df} \cdot se$ 

```{r population sample q5}
# find point estimate of population mean from sample
mean.s50 <- mean(sample50$value)
mean.s50

# find standard error of mean, where se = (sample std dev)/(square root of n)
se.s50 <- sd(sample50$value)/sqrt(50)
se.s50

# find 95% confidence interval for point estimate
t.test.s50 <- t.test(         
 sample50$value,           # the sample vector that you want to test
  mu = mean.pop,          # mean given by null hypothesis, (pop mean)
  alternative = "two.sided",  # direction of alternative hypothesis
  conf.level = 0.95           # significance level, 1 - alpha
  )

t.test.s50$conf.int
```

## Q. 6
```{r population sample q6}
# create a vector to save the sampling distribution of the sample mean
mean.container.s50 <- vector(mode = "numeric", length = 1000)

# set seed to make random code reproducible
set.seed(2021)

# set "for loop" parameters (1000 repetitions of the following code)
for (i in 1:1000){
  # randomly sample 50 rows from pop
  sample <- pop %>% sample_n(size = 50, replace = FALSE)
  # calculate the mean and save it in the container vector
  mean.container.s50[i] <- mean(sample$value)
}
```

## Q. 7
```{r population sample q7}
mean.container.s50 %>% 

  as_tibble() %>%
  
  ggplot(aes(value)) +
  
  geom_histogram(binwidth = 0.01, fill = "grey", color = "black") +
  
  geom_vline(aes(xintercept = mean(value)), 
             color = "red",
             linetype = "dashed") +
  
  geom_text(aes(mean(value), 
  
  label = paste("est population mean =", round(mean(value), 4)),
                y = -1),
            
          colour = "red") +
  
  labs(title = "Sampling Distribution of the Sample Mean (1000 iterations of n = 50)",
  
      subtitle = "Estimate population mean marked by the dashed line",
       
      x = "sample mean")
```

## Q. 8

Sampling distribution mean: $\overline y = \frac{y_1 + y_2 + y+3 + ... + y_n}{n}$

Standard error of sampling distribution: $se = \frac{s}{\sqrt{n}}$

95% Conf. interval of sampling distribution: $\hat \mu \pm t_{0.025, df} \cdot se$ 

```{r population sample q8}
# estimate for population mean is obtained by finding mean of the sampling distribution
# of sample means, which is housed in mean.container.s50
mean.s50.dist <- mean(mean.container.s50)
mean.s50.dist

# find standard error of sampling dist mean, where se = (std dev) / 
# (square root # of samples)
se.s50.dist <- sd(mean.container.s50) / sqrt(length(mean.container.s50))
se.s50.dist

# find the 95% confidence interval for mean of sampling distribution
t.test.s50.dist <- t.test(         
 mean.container.s50,           # sampling dist vector that you want to test
  mu = mean.pop,               # mean given by null hypothesis (pop mean)
  alternative = "two.sided",  # direction of alternative hypothesis
  conf.level = 0.95           # significance level, 1 - alpha
  )

t.test.s50.dist$conf.int
```

## Q. 9.3
```{r population sample q9.3}
#  set seed to make random code reproducible
set.seed(5000)

sample1000 <- pop %>% 
  sample_n(size = 1000, replace = FALSE)
```

## Q. 9.4
```{r population sample q9.4}
sample1000 %>% 

  ggplot(aes(value)) +

  geom_histogram(binwidth = 0.1, fill = "grey", color = "black") +

  geom_vline(aes(xintercept = mean(value)), color = "red", linetype = "dashed") +

  geom_text(aes(mean(value), 
                label = paste("est. population mean =", round(mean(value), 4)),
                y = -2), colour = "red") +

  labs(title = "Sample from Population (n = 1,000, N = 100,000)",

       subtitle = "Estimate population mean marked by dashed line",

       x = "values in sample")
```

## Q. 9.5
```{r population sample q9.5}
# find point estimate of population mean from sample
mean.s1000 <- mean(sample1000$value)
mean.s1000

# find standard error of sample mean, where se = (sample std dev)/(square root of n)
se.s1000 <- sd(sample1000$value)/sqrt(1000)
se.s1000

# find 95% confidence interval for point estimate
t.test.s1000 <- t.test(         
 sample1000$value,           # the sample vector that you want to test
  mu = mean.pop,              # mean given by null hypothesis (pop mean)
  alternative = "two.sided",  # direction of alternative hypothesis
  conf.level = 0.95           # significance level, 1 - alpha
  )

t.test.s1000$conf.int
```

## Q. 9.6
```{r population sample q9.6}
# create a vector to save the sampling distribution of the sample mean
mean.container.s1000 <- vector(mode = "numeric", length = 1000)

# set seed to make random code reproducible
set.seed(1980)

# Set for loop parameters, 1000 repetitions of the following code
for (i in 1:1000){
  # randomly sample 1000 rows from pop
  sample <- pop %>% sample_n(size = 1000, replace = FALSE)
  # calculate the mean and save it in the vector
  mean.container.s1000[i] <- mean(sample$value)
}
```

## Q. 9.7
```{r population sample q9.7}
mean.container.s1000 %>% 

  as_tibble() %>%

  ggplot(aes(value)) +

  geom_histogram(binwidth = 0.01, fill = "grey", color = "black") +

  geom_vline(aes(xintercept = mean(value)), color = "red", linetype = "dashed") +

  geom_text(aes(mean(value), 
       label = paste("est population mean =",

      round(mean(value), 4)), y = -5),

      colour = "red") +
  
  labs(title = "Sampling Distribution of the Sample Mean 
       (1000 iterations of sample n = 1000)",

       subtitle = "Estimate population mean marked by the dashed line",

       x = "sample mean")
```

## Q. 9.8
```{r population sample q9.8}
# estimate for population mean is obtained by finding mean of sampling distribution,
# which is housed in mean.container
mean.s1000.dist <- mean(mean.container.s1000)
mean.s1000.dist

# find standard error of sampling dist mean, where se = (std dev) / 
# (square root # of samples)
se.s1000.dist <- sd(mean.container.s1000) / sqrt(length(mean.container.s1000))
se.s1000.dist

# find the 95% confidence intervals for mean of sampling distribution
t.test.s1000.dist <- t.test(         
 mean.container.s1000,           # sampling dist vector that you want to test
  mu = mean.pop,               # mean given by null hypothesis, or mean of population
  alternative = "two.sided",  # direction of alternative hypothesis
  conf.level = 0.95           # significance level
  )

t.test.s1000.dist$conf.int
```
As a point estimate for the population mean, a sample of n = 1000 is more accurate than a sample of n = 50. However, the mean of the sampling distribution is closer to the population mean when n = 50 than when n = 1000.

The standard error and confidence interval for the sample mean are smaller for n = 1000 compared to n = 50. The same is true for the sampling distributions, where n = 1000 has a smaller standard error and confidence interval. Similarly, the plot of the sampling distribution of the sample mean has both fewer bins and higher counts when n = 1000 compared to n = 50. This visually represents the smaller confidence interval by showing a smaller range over which the sample means are distributed.  

Overall, the tendency for n = 1000 to better approximate the population mean than n = 50 demonstrates the law of large numbers. This law states that the average given by a  sample has an increasingly higher probability of being close to the population average as the size of the sample increases.